'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var colors = require('colorette');
var diff = require('diff');
var os = require('os');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var colors__namespace = /*#__PURE__*/_interopNamespace(colors);

const MESSAGE_TYPE = {
  TEST_START: 'TEST_START',
  ASSERTION: 'ASSERTION',
  TEST_END: 'TEST_END',
  ERROR: 'ERROR',
  UNKNOWN: 'UNKNOWN',
};

const newTestMessage = ({ description, skip }) => ({
  type: MESSAGE_TYPE.TEST_START,
  data: { description, skip },
});

const assertionMessage = (data) => ({
  type: MESSAGE_TYPE.ASSERTION,
  data,
});

const testEndMessage = ({ description, executionTime }) => ({
  type: MESSAGE_TYPE.TEST_END,
  data: {
    description,
    executionTime,
  },
});

const errorMessage = ({ error }) => ({
  type: MESSAGE_TYPE.ERROR,
  data: {
    error,
  },
});

const unknownMessage = ({ message }) => ({
  type: MESSAGE_TYPE.UNKNOWN,
  data: {
    message,
  },
});

const isNode = typeof process !== 'undefined';

const flatDiagnostic = ({ pass, description, ...rest }) => rest;

const createReplacer = () => {
  const visited = new Set();
  return (key, value) => {
    if (isObject(value)) {
      if (visited.has(value)) {
        return '[__CIRCULAR_REF__]';
      }

      visited.add(value);
    }

    if (typeof value === 'symbol') {
      return value.toString();
    }

    return value;
  };
};

const isObject = (candidate) =>
  typeof candidate === 'object' && candidate !== null;

const stringify = (value) => JSON.stringify(value, createReplacer());

const defaultSerializer = stringify;

const defaultLogger = (value) => console.log(value);

const isAssertionFailing = (message) =>
  message.type === MESSAGE_TYPE.ASSERTION && !message.data.pass;

const isSkipped = (message) =>
  message.type === MESSAGE_TYPE.TEST_START && message.data.skip;

const eventuallySetExitCode = (message) => {
  if (isNode && isAssertionFailing(message)) {
    process.exitCode = 1;
  }
};

const compose = (fns) => (arg) =>
  fns.reduceRight((arg, fn) => fn(arg), arg);

const filter = (predicate) =>
  async function* (stream) {
    for await (const element of stream) {
      if (predicate(element)) {
        yield element;
      }
    }
  };

const idSequence = () => {
  let id = 0;
  return () => ++id;
};

const createCounter = () => {
  const nextId = idSequence();
  let success = 0;
  let failure = 0;
  let skip = 0;

  return Object.create(
    {
      increment(message) {
        const { type } = message;
        if (isSkipped(message)) {
          skip++;
        } else if (type === MESSAGE_TYPE.ASSERTION) {
          success += message.data.pass === true ? 1 : 0;
          failure += message.data.pass === false ? 1 : 0;
        }
      },
      nextId,
    },
    {
      success: {
        enumerable: true,
        get() {
          return success;
        },
      },
      failure: {
        enumerable: true,
        get() {
          return failure;
        },
      },
      skip: {
        enumerable: true,
        get() {
          return skip;
        },
      },
      total: {
        enumerable: true,
        get() {
          return skip + failure + success;
        },
      },
    }
  );
};

const createWriter$1 = ({
  log = defaultLogger,
  serialize = defaultSerializer,
  version = 13,
} = {}) => {
  const print = (message, padding = 0) => {
    log(message.padStart(message.length + padding * 4)); // 4 white space used as indent
  };

  const printYAML = (obj, padding = 0) => {
    const YAMLPadding = padding + 0.5;
    print('---', YAMLPadding);
    for (const [prop, value] of Object.entries(obj)) {
      print(`${prop}: ${serialize(value)}`, YAMLPadding + 0.5);
    }
    print('...', YAMLPadding);
  };

  const printComment = (comment, padding = 0) => {
    print(`# ${comment}`, padding);
  };

  const printBailOut = () => {
    print('Bail out! Unhandled error.');
  };

  const printTestStart = (newTestMessage) => {
    const {
      data: { description },
    } = newTestMessage;
    printComment(description);
  };

  const printAssertion = (assertionMessage, { id, comment = '' }) => {
    const { data } = assertionMessage;
    const { pass, description } = data;
    const label = pass === true ? 'ok' : 'not ok';
    const directiveComment = comment ? ` # ${comment}` : '';
    print(`${label} ${id} - ${description}` + directiveComment);
    if (pass === false) {
      printYAML(flatDiagnostic(data));
    }
  };

  const printSummary = ({ success, skip, failure, total }) => {
    print('', 0);
    print(`1..${total}`);
    printComment(`tests ${total}`, 0);
    printComment(`pass  ${success}`, 0);
    printComment(`fail  ${failure}`, 0);
    printComment(`skip  ${skip}`, 0);
  };

  const printHeader = () => {
    print(`TAP version ${version}`);
  };

  return {
    print,
    printYAML,
    printComment,
    printBailOut,
    printTestStart,
    printAssertion,
    printSummary,
    printHeader,
  };
};

const isNotTestEnd = ({ type }) => type !== MESSAGE_TYPE.TEST_END;
const filterOutTestEnd = filter(isNotTestEnd);

const writeMessage$1 = ({ writer, nextId }) => {
  const writerTable = {
    [MESSAGE_TYPE.ASSERTION](message) {
      return writer.printAssertion(message, { id: nextId() });
    },
    [MESSAGE_TYPE.TEST_START](message) {
      if (message.data.skip) {
        const skippedAssertionMessage = assertionMessage({
          description: message.data.description,
          pass: true,
        });
        return writer.printAssertion(skippedAssertionMessage, {
          comment: 'SKIP',
          id: nextId(),
        });
      }
      return writer.printTestStart(message);
    },
    [MESSAGE_TYPE.ERROR](message) {
      writer.printBailOut();
      throw message.data.error;
    },
  };
  return (message) => writerTable[message.type]?.(message);
};

var index$2 = ({ log = defaultLogger, serialize = defaultSerializer } = {}) =>
  async (messageStream) => {
    const writer = createWriter$1({
      log,
      serialize,
    });
    const counter = createCounter();
    const write = writeMessage$1({ writer, nextId: counter.nextId });
    const stream = filterOutTestEnd(messageStream);

    writer.printHeader();
    for await (const message of stream) {
      counter.increment(message);
      write(message);
      eventuallySetExitCode(message);
    }
    writer.printSummary(counter);
  };

var index$1 = ({
  log = defaultLogger,
  serialize = defaultSerializer,
} = {}) => {
  const print = compose([log, serialize]);
  return async (messageStream) => {
    for await (const message of messageStream) {
      eventuallySetExitCode(message);
      print(message);
    }
  };
};

const createStack = () => {
  const items = [];
  const stack = {
    [Symbol.iterator]() {
      return items[Symbol.iterator]();
    },
    push(item) {
      items.push(item);
      return stack;
    },
    pop() {
      return items.pop();
    },
  };
  return stack;
};

const curry2 = (fn) => (a, b) => {
  if (b === void 0) {
    return (b) => fn(a, b);
  }

  return fn(a, b);
};

const leftPad = curry2((offset, string) =>
  string.padStart(string.length + offset)
);

const rightPad = curry2((offset, string) =>
  string.padEnd(string.length + offset)
);

const withMargin = compose([leftPad(1), rightPad(1)]);

const typeAsString = (value) => {
  if (typeof value === 'object') {
    return value?.constructor?.name ?? String(value);
  }
  return typeof value;
};

const badge = (fn) => compose([fn, colors.bold, withMargin, String]);

const createTheme = ({
  bgError = colors__namespace.bgRed,
  bgSuccess = colors__namespace.bgGreen,
  bgSkip = colors__namespace.bgYellow,
  disableFont = colors__namespace.gray,
  badgeFont = colors__namespace.whiteBright,
  adornerFont = colors__namespace.cyan,
} = {}) => {
  const success = compose([bgSuccess, badgeFont]);
  const error = compose([bgError, badgeFont]);
  return {
    errorBadge: badge(error),
    successBadge: badge(success),
    skipBadge: badge(compose([bgSkip, badgeFont])),
    disable: compose([disableFont, withMargin]),
    header: colors.bold,
    adorner: adornerFont,
    emphasis: compose([colors.underline, colors.bold]),
    operator: adornerFont,
    light: disableFont,
    diffExpected: success,
    diffActual: error,
  };
};

var okDiagnostic = (theme) =>
  ({ actual }) =>
    `expected ${theme.emphasis('"truthy"')} but got ${theme.emphasis(
      actual === '' ? '""' : actual
    )}`;

var notOkDiagnostic = (theme) =>
  ({ actual }) =>
    `expected ${theme.emphasis('"falsy"')} but got ${theme.emphasis(
      JSON.stringify(actual)
    )}`;

var failDiagnostic = (theme) =>
  ({ description }) =>
    `expected ${theme.emphasis(
      'fail'
    )} not to be called, but was called as ${theme.emphasis(
      JSON.stringify(description)
    )}`;

var notEqualDiagnostic = (theme) => () =>
  `expected the arguments ${theme.emphasis(
    'not to be equivalent'
  )} but they were`;

var isDiagnostic = (theme) => () =>
  `expected ${theme.emphasis('references to be the same')} but they were not`;

var isNotDiagnostic = (theme) => () =>
  `expected ${theme.emphasis('references not to be the same')} but they were`;

var throwsDiagnostic = (theme) => (m) => {
  const { actual, expected } = m;
  return expected !== void 0
    ? `expected the error thrown to match ${theme.emphasis(
        expected
      )} but it matched ${theme.emphasis(actual)}`
    : `expected ${theme.emphasis('to throw')} but it did not`;
};

const actualParts = ({ added }) => added !== true;
const expectedParts = ({ removed }) => removed !== true;

const mapActualParts =
  (theme) =>
  ({ value, removed }) =>
    removed ? theme.diffActual(value) : value;

const mapExpectedParts =
  (theme) =>
  ({ value, added }) =>
    added ? theme.diffExpected(value) : value;

const getDiffCharThemedMessage =
  (theme) =>
  ({ actual, expected }) => {
    const diffs = diff.diffChars(actual, expected);
    return {
      actual: diffs.filter(actualParts).map(mapActualParts(theme)).join(''),
      expected: diffs
        .filter(expectedParts)
        .map(mapExpectedParts(theme))
        .join(''),
    };
  };

const diffStrings = (theme) => {
  const diffChars = getDiffCharThemedMessage(theme);
  return ({ expected, actual }) => {
    const { expected: expectedMessage, actual: actualMessage } = diffChars({
      expected,
      actual,
    });

    return `diff in strings:
  ${theme.errorBadge('- actual')} ${theme.successBadge('+ expected')}

  ${theme.errorBadge('-')} ${actualMessage}
  ${theme.successBadge('+')} ${expectedMessage}`;
  };
};

const diffNumbers =
  (theme) =>
  ({ expected, actual }) =>
    `expected number to be ${theme.successBadge(
      expected
    )} but got ${theme.errorBadge(actual)}`;

const diffBigInts =
  (theme) =>
  ({ expected, actual }) =>
    `expected bigint to be ${theme.successBadge(
      expected
    )} but got ${theme.errorBadge(actual)}`;

const diffDates = (theme) => {
  const diffChars = getDiffCharThemedMessage(theme);
  return ({ expected, actual }) => {
    const { expected: expectedMessage, actual: actualMessage } = diffChars({
      expected: expected.toISOString(),
      actual: actual.toISOString(),
    });

    return `diff in dates:
  ${theme.errorBadge('- actual')} ${theme.successBadge('+ expected')}

  ${theme.errorBadge('-')} ${actualMessage}
  ${theme.successBadge('+')} ${expectedMessage}`;
  };
};

const diffBooleans =
  (theme) =>
  ({ expected, actual }) =>
    `expected boolean to be ${theme.emphasis(
      expected
    )} but got ${theme.emphasis(actual)}`;

const expandNewLines = (lines) =>
  lines.flatMap((line) => {
    const { value, ...rest } = line;
    return value
      .split(os.EOL)
      .filter(Boolean)
      .map((newValue) => ({
        ...rest,
        value: newValue,
      }));
  });

const diffLine = (theme) => (diff) => {
  if (diff.added) {
    return `${theme.successBadge('+')} ${diff.value}`;
  }

  if (diff.removed) {
    return `${theme.errorBadge('-')} ${diff.value}`;
  }

  return leftPad(3, theme.disable(diff.value));
};

const getDiffJSONThemedMessage = (theme) => {
  const getLineDiff = diffLine(theme);
  return ({ actual, expected }) => {
    const diff$1 = diff.diffJson(actual, expected);
    return expandNewLines(diff$1).map(getLineDiff).map(leftPad(2)).join(os.EOL);
  };
};

const diffObjects = (theme) => {
  const diffJSON = getDiffJSONThemedMessage(theme);
  return ({ expected, actual }) => `diff in objects:
  ${theme.errorBadge('- actual')} ${theme.successBadge('+ expected')}

${diffJSON({ actual, expected })}`;
};

const getDifferentTypeMessage = (theme) => {
  const printType = compose([theme.emphasis, typeAsString]);

  return ({ actual, expected }) =>
    `expected a ${printType(expected)} but got a ${printType(actual)}`;
};

var equalDiagnostic = (theme) => {
  const differentTypes = getDifferentTypeMessage(theme);

  const sameTypeDiff = {
    ['number']: diffNumbers(theme),
    ['bigint']: diffBigInts(theme),
    ['string']: diffStrings(theme),
    ['boolean']: diffBooleans(theme),
    ['object']: ({ expected, actual }) => {
      if (expected.constructor === Date) {
        return diffDates(theme)({ expected, actual });
      }
      return diffObjects(theme)({ actual, expected });
    },
  };

  return (diag) => {
    const { actual, expected } = diag;
    const expectedType = typeof expected;

    if (typeof actual !== expectedType) {
      return differentTypes({ actual, expected });
    }

    return (
      sameTypeDiff[expectedType]?.(diag) ??
      `unsupported type ${theme.emphasis(expectedType)}`
    );
  };
};

var timeoutDiagnostic = () =>
  ({ actual }) =>
    actual;

var getDiagnosticMessage = ({ theme }) => {
  const operators = {
    ok: okDiagnostic(theme),
    notOk: notOkDiagnostic(theme),
    fail: failDiagnostic(theme),
    notEqual: notEqualDiagnostic(theme),
    is: isDiagnostic(theme),
    isNot: isNotDiagnostic(theme),
    throws: throwsDiagnostic(theme),
    equal: equalDiagnostic(theme),
    timeout: timeoutDiagnostic(),
  };

  const unknown = ({ operator }) =>
    `unknown operator ${theme.emphasis(operator)}`;

  return (diag) => operators[diag.operator]?.(diag) ?? unknown(diag);
};

const hasSome = (label) => (counter) => counter[label] > 0;
const hasFailure = hasSome('failure');
const hasSkip = hasSome('skip');

const getPad =
  ({ total }) =>
  (number) =>
    String(number).padStart(String(total).length + 2);

var getSummaryMessage = ({ theme }) => {
  return {
    fail(counter) {
      const padNumber = getPad(counter);
      const label = `FAIL:${padNumber(counter.failure)}`;
      return hasFailure(counter)
        ? theme.errorBadge(label)
        : theme.disable(label);
    },
    pass(counter) {
      const padNumber = getPad(counter);
      const label = `PASS:${padNumber(counter.success)}`;
      return hasFailure(counter)
        ? theme.disable(label)
        : theme.successBadge(label);
    },
    skip(counter) {
      const padNumber = getPad(counter);
      const label = `SKIP:${padNumber(counter.skip)}`;
      return hasSkip(counter) ? theme.skipBadge(label) : theme.disable(label);
    },
    total(counter) {
      return theme.header(`TOTAL:  ${counter.total}`);
    },
  };
};

const createWriter = ({
  log = defaultLogger,
  theme = createTheme(),
} = {}) => {
  const print = compose([log, leftPad(2)]);

  const diagnostics = getDiagnosticMessage({ theme });
  const summary = getSummaryMessage({ theme });

  const printDiagnostic = (diag) => {
    const { description, operator } = diag;
    print('');
    const operatorString = theme.operator(`[${operator}]`);
    print(description);
    print(`${operatorString} ${diagnostics(diag)}`);
  };

  const printSummary = (counter) => {
    print('');
    print(summary.total(counter));
    print(summary.pass(counter));
    print(summary.fail(counter));
    print(summary.skip(counter));
    print('');
  };

  const printLocation = (at) => print(`${theme.light('at')}: ${at}`);

  const printFailingTestPath = (stack) => {
    print('');
    const testPath = [...stack];
    const current = testPath.pop();
    print(
      `${theme.errorBadge('FAIL')} ${theme.header(
        [...testPath, theme.emphasis(current)].join(
          theme.adorner(withMargin('>'))
        )
      )}`
    );
  };

  return {
    printDiagnostic,
    print,
    printSummary,
    printFailingTestPath,
    printLocation,
  };
};

const writeMessage = ({ writer, stack }) => {
  const writeTable = {
    [MESSAGE_TYPE.TEST_START](message) {
      stack.push(message.data.description);
    },
    [MESSAGE_TYPE.TEST_END]() {
      stack.pop();
    },
    [MESSAGE_TYPE.ASSERTION](message) {
      if (isAssertionFailing(message)) {
        writer.printFailingTestPath(stack);
        if (message.data.at) {
          writer.printLocation(message.data.at);
        }
        writer.printDiagnostic(message.data);
      }
    },
    [MESSAGE_TYPE.ERROR](message) {
      // todo
      throw message.data.error;
    },
  };

  return (message) => writeTable[message.type]?.(message);
};

var index = () => async (messageStream) => {
  const counter = createCounter();
  const stack = createStack();
  const writer = createWriter();
  const write = writeMessage({ writer, stack });

  for await (const message of messageStream) {
    write(message);
    counter.increment(message);
    eventuallySetExitCode(message);
  }
  writer.printSummary(counter);
};

exports.MESSAGE_TYPE = MESSAGE_TYPE;
exports.assertionMessage = assertionMessage;
exports.createDiffReporter = index;
exports.createJSONReporter = index$1;
exports.createTAPReporter = index$2;
exports.errorMessage = errorMessage;
exports.newTestMessage = newTestMessage;
exports.testEndMessage = testEndMessage;
exports.unknownMessage = unknownMessage;
